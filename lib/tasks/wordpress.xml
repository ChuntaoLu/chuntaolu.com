<?xml version="1.0" encoding="UTF-8"?>
<!--
 This is a WordPress eXtended RSS file generated by WordPress as an export of your site.
 It contains information about your site's posts, pages, comments, categories, and other content.
 You may use this file to transfer that content from one site to another.
 This file is not intended to serve as a complete backup of your site.

 To import this information into a WordPress site follow these steps:
 1. Log in to that site as an administrator.
 2. Go to Tools: Import in the WordPress admin panel.
 3. Install the "WordPress" importer from the list.
 4. Activate & Run Importer.
 5. Upload this file using the form provided on that page.
 6. You will first be asked to map the authors in this export file to users
    on the site. For each author, you may choose to map to an
    existing user on the site or to create a new user.
 7. WordPress will then import each of the posts, pages, comments, categories, etc.
    contained in this file into your site.
-->
<!-- generator="WordPress.com" created="2014-02-10 02:03"-->
<rss version="2.0" xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:wp="http://wordpress.org/export/1.2/">
  <channel>
<title>Teacode's Python Journey</title>
<link>http://teacode.wordpress.com</link>
<description>Happy learning everyday!</description>
<pubDate>Mon, 10 Feb 2014 02:03:07 +0000</pubDate>
<language>en</language>
<wp:wxr_version>1.2</wp:wxr_version>
<wp:wp_author>
  <wp:author_first_name><![CDATA[]]></wp:author_first_name>
  <wp:author_last_name><![CDATA[]]></wp:author_last_name>
</wp:wp_author>
<generator>http://wordpress.com/</generator>
<image>
		<url>http://s2.wp.com/i/buttonw-com.png</url>
		<title>Teacode&#039;s Python Journey</title>
		<link>http://teacode.wordpress.com</link>
	</image>
	<item>
  <title>Level 2  map</title>
  <link>http://teacode.wordpress.com/2013/06/26/1-map/</link>
  <pubDate>Wed, 26 Jun 2013 18:40:08 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=3</guid>
  <description/>
  <content:encoded><![CDATA[I simply follow the mapping rules by shifting certain digits, which solves the problem flawlessly.
The better solution I learned is to establish a 'translate table'.

[code language="python"]
from string import maketrans

From = 'abcde'
To = '12345'
trantab = maketrans(From, To)
text = 'a is less than bc'
print text.translate(trantab)
[/code]

The output above should be <code>'1 is l5ss th1n 23'</code>.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>3</wp:post_id>
  <wp:post_date>2013-06-26 14:40:08</wp:post_date>
  <wp:post_date_gmt>2013-06-26 18:40:08</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>1-map</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="programming"><![CDATA[Programming]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-06-26 21:13:38";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 3 equality</title>
  <link>http://teacode.wordpress.com/2013/06/26/level-3-equality/</link>
  <pubDate>Wed, 26 Jun 2013 20:03:45 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=18</guid>
  <description/>
  <content:encoded><![CDATA[The aim is to find the letters that satisfy the pattern of one lowercase surrounded EXACTLY by three uppercase.
The easy way to do this is regular expressions.

[code language="python"]
import re

text = 'aSDFgHJKlzxcVBNM,UG' # random text
out = ''.join(re.findall('[a-z][A-Z]{3}([a-z])[A-Z]{3}[a-z]', text))
[/code]

regular expressions <a href="http://docs.python.org/2/howto/regex.html" target="_blank">HOWTO</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>18</wp:post_id>
  <wp:post_date>2013-06-26 16:03:45</wp:post_date>
  <wp:post_date_gmt>2013-06-26 20:03:45</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-3-equality</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 4 linkedlist</title>
  <link>http://teacode.wordpress.com/2013/06/26/level-4-linkedlist/</link>
  <pubDate>Wed, 26 Jun 2013 20:31:01 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=36</guid>
  <description/>
  <content:encoded><![CDATA[The useful modules I learned are <code>urllib</code>(or <code>urllib2</code>) and <code>webbrowser</code>

[code language="python"]
import urllib, webbrowser

prefix = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='
num = '12345'
html = urllib.urlopen(prefix + num).read()   # read the html as string
num = ''.join(d for d in html if d.isdigit())
webbrowser.open(prefix + num)
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>36</wp:post_id>
  <wp:post_date>2013-06-26 16:31:01</wp:post_date>
  <wp:post_date_gmt>2013-06-26 20:31:01</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-4-linkedlist</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="programming"><![CDATA[Programming]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="urllib"><![CDATA[urllib]]></category>
  <category domain="post_tag" nicename="webbrowser"><![CDATA[webbrowser]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-06-26 21:15:07";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 5 pickle</title>
  <link>http://teacode.wordpress.com/2013/06/26/level-5-pickle/</link>
  <pubDate>Wed, 26 Jun 2013 20:51:27 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=39</guid>
  <description/>
  <content:encoded><![CDATA['peak hell' pronounces like 'pickle', and the key is the <code>pickle</code> module.

[code language="python"]
import urllib2, pickle

url = 'http://www.pythonchallenge.com/pc/def/banner.p'
data = pickle.loads(urllib2.urlopen(url).read())
for line in data:
    print ''.join(elmt[0] * elmt[1] for elmt in line)
[/code]

<code>pickle.load()</code> unpickles a pickled file
<code>pickle.loads()</code> unpickles a string(which might be read from a file);
<code>pickle.dump()</code> pickles to a file
<code>pickle.dumps()</code> pickles to a string.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>39</wp:post_id>
  <wp:post_date>2013-06-26 16:51:27</wp:post_date>
  <wp:post_date_gmt>2013-06-26 20:51:27</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-5-pickle</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="pickle"><![CDATA[pickle]]></category>
  <category domain="post_tag" nicename="programming"><![CDATA[Programming]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-06-26 21:19:01";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 6 channel </title>
  <link>http://teacode.wordpress.com/2013/06/26/level-6-channel/</link>
  <pubDate>Wed, 26 Jun 2013 21:31:37 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=47</guid>
  <description/>
  <content:encoded><![CDATA[The hint in the source page suggests replace '.html' by '.zip', doing so leads to a zip file.
Unzip and the 'readme.txt' reveals further hints.

[code language="python"]
import re, zipfile

inFile = zipfile.ZipFile('channel.zip')
num= '90052'
end = '.txt'
cmt = ''
while True:
    try:
        text = inFile.read(num + end)
    except:
        break
    cmt += inFile.getinfo(num + end).comment
    print text
    num = ''.join(re.findall('nothing is ([0-9]*)', text))

print cmt
[/code]

<code>zipfile</code> module has <code>.ZipFile()</code> method which reads a zip file.
<code>.namelist()</code> pulls out the name list in the zip file.
<code>.getinfo(file)</code> returns a object which contains the info for the individual file.
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>47</wp:post_id>
  <wp:post_date>2013-06-26 17:31:37</wp:post_date>
  <wp:post_date_gmt>2013-06-26 21:31:37</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-6-channel</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="zipfile"><![CDATA[zipfile]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 7 oxygen</title>
  <link>http://teacode.wordpress.com/2013/06/27/level-7-oxygen/</link>
  <pubDate>Thu, 27 Jun 2013 16:26:28 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=50</guid>
  <description/>
  <content:encoded><![CDATA[My gut feeling is to manipulate the image since there is some grey area.
I did install the <code>PIL</code> and try to use the <code>Image</code> module, but I am not smart enough to figure out the puzzle. So I googled it =)

[code language="python"]
import Image, re

img = Image.open('oxygen.png')
#img.show()
#First find the grey area. For grey, r = g = b
y = 0
while True:
    r, g, b, a = img.getpixel((0, y)) #x is 0, where grey is apparent
    if r == g == b:
        break
    y += 1
#Each gray area is 7 pixels wide.
message = ''.join([chr(img.getpixel((x, y))[0]) for x in range(0, img.size[0], 7)])
out = re.findall('\d+', message)
print message
print ''.join(chr(int(i)) for i in out)
[/code]

The <code>Image</code> module is quite powerful.
<code>Image.open()</code> returns a image object, whose info can be accessed by <code>.format</code>, <code>.size</code>, <code>.bits</code>.
<code>.getpixel()</code> takes a pixel's coordinate and returns its rbga info as a tuple.
<code>chr()</code> takes a integer(between 0 and 255) and returns a string of one character.

PS.
Color 'grey' has property of r = g = b;
<a href="http://rick.measham.id.au/paste/explain.pl" target="_blank">Regex online explainer.</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>50</wp:post_id>
  <wp:post_date>2013-06-27 12:26:28</wp:post_date>
  <wp:post_date_gmt>2013-06-27 16:26:28</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-7-oxygen</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="chr"><![CDATA[chr]]></category>
  <category domain="post_tag" nicename="image"><![CDATA[Image]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="re"><![CDATA[re]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-06-27 16:27:36";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 8 integrity</title>
  <link>http://teacode.wordpress.com/2013/06/28/level-8-integrity/</link>
  <pubDate>Fri, 28 Jun 2013 17:35:25 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=54</guid>
  <description/>
  <content:encoded><![CDATA[As the journey goes on, those challenges are increasingly beyond my scope.
However, it serves as a pretty good way to explore python. I enjoyed.

The hidden link is on the bee, clicking which leads to a pop-out for username and password.
There is also a hint "inflate", which suggests 'decompress'.

The header of the provided strings are "BZh9...", apparently (according to Google) it refers to <code>BZip2</code> compression.

[code language="python"]
import bz2

un = 'BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084'
pw = 'BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08'

username = 'username: ' + bz2.decompress(un)
password = 'password: ' + bz2.decompress(pw)
print username
print password
[/code]

If you know what the header suggests and the <code>bz2</code> module, then the puzzle is actually simple.
It can also be solved by the <code>.decode()</code> method (the encoding is 'bz'), this <a href="http://www.tutorialspoint.com/python/string_decode.htm">link</a> shows howto. ]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>54</wp:post_id>
  <wp:post_date>2013-06-28 13:35:25</wp:post_date>
  <wp:post_date_gmt>2013-06-28 17:35:25</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-8-integrity</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="bz2"><![CDATA[bz2]]></category>
  <category domain="post_tag" nicename="decode"><![CDATA[decode]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>level 9 bull</title>
  <link>http://teacode.wordpress.com/2013/06/29/level-9-bull/</link>
  <pubDate>Sat, 29 Jun 2013 18:45:25 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=56</guid>
  <description/>
  <content:encoded><![CDATA[My mind is still on level 7 when it comes to image tweaks. It was no go.
I find UnixWars, again.

I concentrated on the tree image and the dots, while it turns out the solution has not much to do with those. "Dots" refer to the points in the source page. I was expecting a dot being a 2-tuple, but the truth is the <code>.line()</code> or the <code>.polygon()</code> method(from the <code>ImageDraw</code> module) work with both 2-tuples list and even numbered list. Namely, you can still "connect the dots" without worrying about whether the data are a list of 2-tuples or a list of just numbers.

[code language="python"]
import Image, ImageDraw

first = open('first.txt').read().split(',')
second = open('second.txt').read().split(',')
list_1 = [int(i) for i in first]
list_2 = [int(i) for i in second]
img = Image.new('RGB', (500, 500), 'black')
draw = ImageDraw.Draw(img)
draw.line(list_1)
draw.line(list_2)
img.show()
[/code]

<a href="http://effbot.org/imagingbook/">PIL Handbook</a>]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>56</wp:post_id>
  <wp:post_date>2013-06-29 14:45:25</wp:post_date>
  <wp:post_date_gmt>2013-06-29 18:45:25</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-9-bull</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="imagedraw"><![CDATA[ImageDraw]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>level 10 5808</title>
  <link>http://teacode.wordpress.com/2013/07/01/level-10-5808/</link>
  <pubDate>Mon, 01 Jul 2013 17:05:40 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=61</guid>
  <description/>
  <content:encoded><![CDATA[1, 11, 21, 1211, 111221, ... turns out to be a sequence called "look and say sequence".
I use basic <code>if</code> and <code>while</code> functions to get the work done, but the code is ugly.

[code language="python"]
def look_and_say(n):
    num = str(n)
    i = 0
    new = ''
    while i &lt; len(num):
        counter = 1
        if i == (len(num)-1):
            new += str(counter) + num[i]
            break
        while num[i] == num[i+1]:
            i += 1
            counter += 1
            if i == (len(num)-1):
                break
        new += str(counter) + num[i]
        i += 1
    return int(new)
[/code]

A better solution is to implement with Regex:

[code language="python"]
import re

def look_and_say(n):
    num = str(n)
    sets = re.findall('(1+|2+|3+)', num)
    return ''.join([str(len(x)) + x[0] for x in sets])
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>61</wp:post_id>
  <wp:post_date>2013-07-01 13:05:40</wp:post_date>
  <wp:post_date_gmt>2013-07-01 17:05:40</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-10-5808</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="re"><![CDATA[re]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Algo week 1: Merge sort</title>
  <link>http://teacode.wordpress.com/2013/07/01/merge-sort/</link>
  <pubDate>Tue, 02 Jul 2013 02:15:41 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=65</guid>
  <description/>
  <content:encoded><![CDATA[The idea of merge sort is to divide a sequence into 2 sub-sequences, sort and then merge back into one sequence. The whole process is done recursively, and the running time cost is $latex 6nlog_{2}n + 6n$.<!--more-->

[code language="python"]
def merge(a, b):
    c = []
    i, j = 0, 0
    while i &lt; len(a) and j &lt; len(b):
        if a[i] &lt;= b[j]:
            result.append(a[i])
            i += 1
        else:
            result.append(b[j])
            j += 1
     #When we met an end in either sublist,
     #we simply copy the remaining portion to the result.
     result += a[i:]
     result += b[j:]
     return result
[/code]

Below is an alternative way to get rid of possible 'index out of range' issue:
[code language="python"]
def merge(a, b):
    '''function to merge 2 sorted list'''

    a.append(float('inf')) #add infinite max to avoid index issue
    b.append(float('inf'))
    i ,j = 0, 0
    c = []
    for k in range(len(a)+len(b)-2):
        if a[i] &lt; b[j]:
            c.append(a[i])
            i += 1
        else:
            c.append(b[j])
            j += 1
    return c
[/code]

After implementing merge function, what left is simple divde-and-conquer.
[code language="python"]
def merge_sort(seq):
    '''recursive function to merge and sort'''

    if len(seq) == 1:
        return seq
    else:
        mid = int(len(seq)/2)
        head = merge_sort(seq[:mid])
        end = merge_sort(seq[mid:])
        return merge(head, end)
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>65</wp:post_id>
  <wp:post_date>2013-07-01 22:15:41</wp:post_date>
  <wp:post_date_gmt>2013-07-02 02:15:41</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>merge-sort</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="index-out-of-range"><![CDATA[index out of range]]></category>
  <category domain="post_tag" nicename="merge-sort"><![CDATA[merge sort]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 11 evil</title>
  <link>http://teacode.wordpress.com/2013/07/02/level-11-evil/</link>
  <pubDate>Tue, 02 Jul 2013 16:18:03 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=70</guid>
  <description/>
  <content:encoded><![CDATA[It's image processing again. I wasn't clear how to distinguish between odd and even when there are two coordinates x and y. If pixels whose x and y are both odd (or even) contribute to one image and the rest for the other, then the two images are not equally sized (which turns out not to be a problem). A better way to get equal sized images is to take the product of the width and height of the original image then split that product to odd and even. The corresponding pixel coordinate is decided by <code>divmod(product, width)</code>.<!--more-->

[code language="python"]
import urllib, Image, StringIO

url = 'http://www.pythonchallenge.com/pc/return/cave.jpg'
pic = urllib.urlopen(url).read()
img = Image.open(StringIO.StringIO(pic))
w, h = img.size
new = Image.new('RGB', (w, h))

counter = 0
#alternative way, works but not optimal
#for i in range(w):
#    for j in range(h):
#        p = img.getpixel((i,j))
#        if i%2 and j%2:#for the odd
#            counter += 1
#            new.putpixel((i/2, j/2), p)
#        else:
#            new.putpixel((i/2, j/2 + h/2), p)
for i in range(w*h):
    y, x = divmod(i, w)
    p = img.getpixel((x,y))
    if i%2:
        new.putpixel((x/2, y/2), p)
        counter += 1
    else:
        new.putpixel((x/2, y/2+h/2), p)
new.show()
print counter


#one liner without using the hint
#img.resize((img.size[0]/2, img.size[1]/2)).show()
[/code]
<code>.putpixel()</code> method takes target position and colors.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>70</wp:post_id>
  <wp:post_date>2013-07-02 12:18:03</wp:post_date>
  <wp:post_date_gmt>2013-07-02 16:18:03</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-11-evil</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="divmod"><![CDATA[divmod]]></category>
  <category domain="post_tag" nicename="image"><![CDATA[Image]]></category>
  <category domain="post_tag" nicename="pil"><![CDATA[pil]]></category>
  <category domain="post_tag" nicename="putpixel"><![CDATA[putpixel]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="urllib"><![CDATA[urllib]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-07-02 16:28:02";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 12 dispropotional</title>
  <link>http://teacode.wordpress.com/2013/07/03/level-12-dispropotional/</link>
  <pubDate>Wed, 03 Jul 2013 17:02:57 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=75</guid>
  <description/>
  <content:encoded><![CDATA[I have to admit that I am not a good puzzle solver :(
After I googled everything, it is pointless to redundantly describe how to figure out everything.

What I learned:
<ul>
	<li>.gfx file is a graphic file.</li>
	<li><code>open('image.jpg','wb').write()</code> creates a new image and writes to it.</li>
	<li><code>seq[start:stop:step]</code> is every 'step' element of the seq. 'start' and 'stop' are optional.</li>
</ul>

[code language="python"]
f = open('evil2.gfx','r').read()

for i in range(0,5):
    open(&quot;image&quot;+str(i)+&quot;.jpg&quot;, &quot;wb&quot;).write(f[i::5])
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>75</wp:post_id>
  <wp:post_date>2013-07-03 13:02:57</wp:post_date>
  <wp:post_date_gmt>2013-07-03 17:02:57</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-12-dispropotional</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="image"><![CDATA[Image]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-07-03 17:02:57";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 13 italy</title>
  <link>http://teacode.wordpress.com/2013/07/04/level-13-italy/</link>
  <pubDate>Thu, 04 Jul 2013 16:55:38 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=100</guid>
  <description/>
  <content:encoded><![CDATA[What I could reach is to find out that xml error page, and the 'remote' tag looked suspicious.
Never aware of the <code>xmlrpclib</code> module, I still have no idea of what it does.
Maybe I could dig more about it when time allows.

[code language="python"]
import xmlrpclib

url = 'http://www.pythonchallenge.com/pc/phonebook.php'
server = xmlrpclib.ServerProxy(url)
## we'll need to discover Server API
print server.system.listMethods()
print server.phone('Bert')
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>100</wp:post_id>
  <wp:post_date>2013-07-04 12:55:38</wp:post_date>
  <wp:post_date_gmt>2013-07-04 16:55:38</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-13-italy</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="attention-later"><![CDATA[attention later]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="xmlrpclib"><![CDATA[xmlrpclib]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 14 walk around</title>
  <link>http://teacode.wordpress.com/2013/07/05/level-14-walk-around/</link>
  <pubDate>Fri, 05 Jul 2013 16:44:19 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=103</guid>
  <description/>
  <content:encoded><![CDATA[I just realized that I named all the previous levels with their answers instead of actually titles! Silly me!
It will be on the right track from now on, but I am too lazy to change the previous ones.

The directional spiral of the bun was closely connected to the hint in the source page. The idea is to pick up a pixel in wire.png and put it in a 100*100 image in a clockwise spiral fashion. (100+99+99+98) means the steps of the first and outermost spiral, and it goes on like (98+97+97+96), (96+95+95+94)..., (2+1+1+0). And the clockwise directions call be represented by [(1,0), (0,1), (-1,0), (0,-1)]. Once the idea is clear, it is not hard to implement.<!--more-->
[code language="python"]
import Image, urllib, StringIO

url = 'http://huge:file@www.pythonchallenge.com/pc/return/wire.png'
src = urllib.urlopen(url).read()
img = Image.open(StringIO.StringIO(src))
out = Image.new(img.mode, (100, 100))

dirt = [(1,0), (0,1), (-1,0), (0,-1)]
x, y = -1, 0  #start point
counter = 0
for s in range(100, 1, -2):
    dirt_step = [s, s-1, s-1, s-2]
    for i in range(4):
        j = 0
        while j &lt; dirt_step[i]:
            x += dirt[i][0]
            y += dirt[i][1]
            j += 1
            out.putpixel((x, y), img.getpixel((counter, 0)))
            counter += 1
out.show()
[/code]

I find the way <a href="http://unixwars.com/2007/09/20/python-challenge-level-14-walk-around/">UnixWars</a> took care of the steps is crafty and efficient. By utilizing the feature of integer division, he easily generated the pattern of spiral steps. Below is his code:
[code language="python"]
import Image, urllib, StringIO

url = 'http://huge:file@www.pythonchallenge.com/pc/return/wire.png'
src = urllib.urlopen(url).read()
im = Image.open(StringIO.StringIO(src))
new = Image.new(im.mode, (100, 100))

doubled_steps=200
directions=[(1,0), (0,1), (-1,0), (0,-1)] # vectors in [x,y] format
x,y,p=-1,0,0
while doubled_steps//2 &gt; 0:
    for v in directions: # we will be taking steps in 4 directions
        steps=doubled_steps//2
        for s in range(steps):
            x,y=x+v[0],y+v[1]
            new.putpixel((x,y),im.getpixel((p,0)))
            p+=1
        doubled_steps-=1
new.show()
[/code] ]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>103</wp:post_id>
  <wp:post_date>2013-07-05 12:44:19</wp:post_date>
  <wp:post_date_gmt>2013-07-05 16:44:19</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-14-walk-around</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="image"><![CDATA[Image]]></category>
  <category domain="post_tag" nicename="integer-division"><![CDATA[integer division]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-07-05 16:46:13";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 15 whom?</title>
  <link>http://teacode.wordpress.com/2013/07/06/level-15-whom/</link>
  <pubDate>Sat, 06 Jul 2013 15:31:32 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=109</guid>
  <description/>
  <content:encoded><![CDATA[What I found in puzzle: 1) 26 is circled and todo says "buy flowers tomorrow", so birthday is January 27; 2) year is is burned out.
What I was missing: 1) the corner shows February has 29 days, which indicates it's a leap year; 2) I didn't realize the idea is to find a specific date and then google whose birthday that is.

 [code language="python"]
import datetime, calendar


out = []
for year in range(1006, 1997, 10):
    d = datetime.date(year, 1, 27)
    if d.isoweekday() == 2 and calendar.isleap(year):
        out.append(d.isoformat())
print out[-2] #second youngest
[/code]

<code>datetime.date()</code> constructs an instance of <code>datetime</code> object.
<code>.isoweekday()</code> method returns the iso weekday of the date.
<code>.isoformat()</code> method returns the date in iso format.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>109</wp:post_id>
  <wp:post_date>2013-07-06 11:31:32</wp:post_date>
  <wp:post_date_gmt>2013-07-06 15:31:32</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-15-whom</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="calendar"><![CDATA[calendar]]></category>
  <category domain="post_tag" nicename="datetime"><![CDATA[datetime]]></category>
  <category domain="post_tag" nicename="isoformat"><![CDATA[isoformat]]></category>
  <category domain="post_tag" nicename="isoweekday"><![CDATA[isoweekday]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 16 let me get this straight </title>
  <link>http://teacode.wordpress.com/2013/07/07/level-16-let-me-get-this-straight/</link>
  <pubDate>Sun, 07 Jul 2013 19:27:49 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=111</guid>
  <description/>
  <content:encoded><![CDATA[The gif image has the same pink segment at each row, 'straight' means to reassemble each row so that those pink segments lineup at the beginning(or the end). Gif images use palette for colors, of which pink is 195. This means the <code>getpixel()</code> method on gif returns a single integer instead of a 3-tuple(or 4-tuple for rbga).<!--more-->

[code language="python"]
import urllib, Image, StringIO


def straight(line):
    idx = 0
    while line[idx] != 195:
        idx += 1
    return line[idx:] + line[:idx]

url = 'http://huge:file@www.pythonchallenge.com/pc/return/mozart.gif'
fin = urllib.urlopen(url).read()
img = Image.open(StringIO.StringIO(fin))
new = Image.new(img.mode, img.size)
for y in range(img.size[1]):
    line = [img.getpixel((x,y)) for x in range(img.size[0])]
    line = straight(line)
    [new.putpixel((x,y), line[x]) for x in range(img.size[0])]
new.show()
[/code]

ps:
list.index() method can have an optional argument as a search start index.
[code language="python"]
a = [1, 2, 3, 4, 2, 5]
print a.index(2) # prints '1'
print a.index(2,2) # prints '4'
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>111</wp:post_id>
  <wp:post_date>2013-07-07 15:27:49</wp:post_date>
  <wp:post_date_gmt>2013-07-07 19:27:49</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-16-let-me-get-this-straight</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="getpixel"><![CDATA[getpixel]]></category>
  <category domain="post_tag" nicename="gif"><![CDATA[gif]]></category>
  <category domain="post_tag" nicename="image"><![CDATA[Image]]></category>
  <category domain="post_tag" nicename="index"><![CDATA[index]]></category>
  <category domain="post_tag" nicename="putpixel"><![CDATA[putpixel]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>tagazine-media</wp:meta_key>
    <wp:meta_value><![CDATA[a:7:{s:7:"primary";s:0:"";s:6:"images";a:0:{}s:6:"videos";a:0:{}s:11:"image_count";i:0;s:6:"author";s:8:"47389753";s:7:"blog_id";s:8:"54490734";s:9:"mod_stamp";s:19:"2013-07-07 19:30:09";}]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 17 eat?</title>
  <link>http://teacode.wordpress.com/2013/07/08/level-eat/</link>
  <pubDate>Tue, 09 Jul 2013 00:32:51 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=116</guid>
  <description/>
  <content:encoded><![CDATA[This level is way too complicated than I thought. 'Cookie' clearly indicates to investigate what's in level 4. I am totally new to the the concept of Cookie and header. <code>Cookielib</code> is the new module that seems hard to understand. What's worse, this level connects other levels, which include level 4, 8 and 13. Ah, what a mess!

[code language="python"]
import cookielib, urllib2, urllib, re, bz2, time, xmlrpclib


start = time.time()
cj = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))

def get_cookie_info(url):
    request = urllib2.Request(url)
    response = opener.open(request)
    cookies = cj.make_cookies(response, request)
    text = urllib.urlopen(url).read()
    digits = ''.join(re.findall(r'busynothing is (\d+)', text))
    info = urllib.unquote_plus(cookies[0].value)
    return digits, info

url = 'http://www.pythonchallenge.com/pc/def/linkedlist.php'
print get_cookie_info(url)
new_url = url + '?busynothing='
num = '12345'
out = ''
while True:
    num, info = get_cookie_info(new_url + num)
    out += info
    try:
        int(num)
    except:
        break
print bz2.decompress(urllib.unquote_plus(out))
#print time.time() - start

#Mozart's father's name is Leopold
url2 = 'http://www.pythonchallenge.com/pc/phonebook.php'
server = xmlrpclib.ServerProxy(url2)
## we'll need to discover Server API
print server.system.listMethods()
print server.phone('Leopold')
#returns 555-VIOLIN
message = 'the flowers are on their way'
url3 = 'http://www.pythonchallenge.com/pc/stuff/violin.php'
new_opener = urllib2.build_opener()
new_opener.addheaders.append(('Cookie','info='+urllib.quote_plus(message)))
new_request = new_opener.open(url3)
print new_request.read()
[/code]

<code>(re.findall(), text)</code> returns a list of one(or zero) element. <code>''.join(re.findall(), text)</code> is always better than <code>(re.findall(), text)[0]</code>, because it avoids the possible 'index out of range' problem.

Another way to get header info:
[code language="python"]
#below should be in a loop
info = ''
request = urllib.urlopen(url)
cookies = request.info().getheaders('Set-Cookie')[0]
byte = cookies.split(';')[0].split('=')[1]
info += byte
#info is in quote_plus format
print &quot;info:&quot;,bz2.decompress(urllib.unquote_plus(info))
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>116</wp:post_id>
  <wp:post_date>2013-07-08 20:32:51</wp:post_date>
  <wp:post_date_gmt>2013-07-09 00:32:51</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-eat</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="attention-later"><![CDATA[attention later]]></category>
  <category domain="post_tag" nicename="build_opener"><![CDATA[build_opener]]></category>
  <category domain="post_tag" nicename="bz2"><![CDATA[bz2]]></category>
  <category domain="post_tag" nicename="cookiejar"><![CDATA[CookieJar]]></category>
  <category domain="post_tag" nicename="cookielib"><![CDATA[cookielib]]></category>
  <category domain="post_tag" nicename="make_cookies"><![CDATA[make_cookies]]></category>
  <category domain="post_tag" nicename="opener"><![CDATA[opener]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="re"><![CDATA[re]]></category>
  <category domain="post_tag" nicename="unquote_plus"><![CDATA[unquote_plus]]></category>
  <category domain="post_tag" nicename="urlib-quote_plus"><![CDATA[urlib.quote_plus]]></category>
  <category domain="post_tag" nicename="urllib"><![CDATA[urllib]]></category>
  <category domain="post_tag" nicename="urllib2"><![CDATA[urllib2]]></category>
  <category domain="post_tag" nicename="urllib2-request"><![CDATA[urllib2.Request]]></category>
  <category domain="post_tag" nicename="xmlrpclib"><![CDATA[xmlrpclib]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>level 18 can you tell the difference?</title>
  <link>http://teacode.wordpress.com/2013/07/09/level-18-can-you-tell-the-difference/</link>
  <pubDate>Tue, 09 Jul 2013 20:59:52 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=122</guid>
  <description/>
  <content:encoded><![CDATA[I was naive to think it's just the subtraction of the two images, I should mock myself, I mean it's level 18! 'brightness.html' leads to 'deltas.gz', and the unzipped file shows hex numbers in two parts. Some lines are same, and others are different. I wish I knew the header for .png file is <em>89 50 4E 47 0D 0A 1A 0A</em>. The most interesting module at this level is <code>difflib</code>. <code>difflib.ndiff(a, b)</code> compares the two lists of strings and return a generator object(which generates delta lines). <code>list(difflib.ndiff(a, b))</code> converts the object to a list, in which each string has a '+ ', '- ' or '  ' at the start. '  ' means the string is common, '- ' means it's unique in <code>a</code> and '+ ' means it's unique in <code>b</code>. <code>.open()</code> opens a file as a <code>file</code> object, to write to it use <code>.write(somestring)</code>. <code>gzip</code> module handles <code>.gz</code> zip files.

[code language="python"]
import urllib, Image, gzip, StringIO, difflib


url = 'http://huge:file@www.pythonchallenge.com/pc/return/deltas.gz'
data = urllib.urlopen(url).read()
fin = gzip.GzipFile(fileobj=StringIO.StringIO(data))
#equivalent .gz file opening below
#data = urllib.urlretrieve(url, 'deltas.gz')
#fin = gzip.open('deltas.gz', 'rb')

left, right, out = [], [], ['', '', '']
for line in fin:
    l = line.strip()
    left.append(l[:53])
    right.append(l[56:])

diff = list(difflib.ndiff(left, right))

for line in diff:
    string = [chr(int(c, 16)) for c in line[2:].split()]
    if line[0] == '-':
        out[0] += ''.join(string)
    elif line[0] == '+':
        out[1] += ''.join(string)
    else:
        out[2] += ''.join(string)

for i in range(3):
    open('18_%d.png' % i, 'wb').write(out[i])
[/code]



]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>122</wp:post_id>
  <wp:post_date>2013-07-09 16:59:52</wp:post_date>
  <wp:post_date_gmt>2013-07-09 20:59:52</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-18-can-you-tell-the-difference</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="chr"><![CDATA[chr]]></category>
  <category domain="post_tag" nicename="difflib"><![CDATA[difflib]]></category>
  <category domain="post_tag" nicename="difflib-ndiff"><![CDATA[difflib.ndiff]]></category>
  <category domain="post_tag" nicename="file-write"><![CDATA[file.write()]]></category>
  <category domain="post_tag" nicename="gzip"><![CDATA[gzip]]></category>
  <category domain="post_tag" nicename="png"><![CDATA[png]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="urllib"><![CDATA[urllib]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Level 19 please!</title>
  <link>http://teacode.wordpress.com/2013/07/10/level-19-please/</link>
  <pubDate>Wed, 10 Jul 2013 20:40:30 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=126</guid>
  <description/>
  <content:encoded><![CDATA[I didn't get the map part, it turns out to be a hint: 'Indian' just like 'endian'. A lot of info from the html, <em>indian.wav</em> file indicates <code>wave</code> module. I was too <em>unpythonic</em> not realize using <code>email</code> and <code>re</code> module to get the base64 encoded message. Combined with the 'endian' hint, a big endian <em>.wav</em> file is retrieved.

I am including some good alternative snippets that can get the job done. Line number in front of 'alternative'.

[code language="python"]
import urllib, base64, wave, email, re, StringIO


url = 'http://butter:fly@www.pythonchallenge.com/pc/hex/bin.html'
fin = urllib.urlopen(url).read()
match = re.compile('&lt;!--\n(.*)\n--&gt;', re.DOTALL)
mail = ''.join(match.findall(fin))
msg = email.message_from_string(mail)
#--------------5:8-alternative----------------
#fin = urllib.urlretrieve(url, '19.txt')
#lines = open('19.txt').readlines()
#open('19.txt','w').writelines(lines[14:])
#msg = email.message_from_file(open('19.txt'))
#---------------------------------------------

data = msg.get_payload(0).get_payload(decode=True)
#-----------------16-alternative--------------------------
#data = base64.b64decode(msg.get_payload(0).get_payload())
#---------------------------------------------------------

old = wave.open(StringIO.StringIO(data))
#--------21-alternative--------
#open('19.wav','w').write(data)
#old = wave.open('19.wav','rb')
#------------------------------

#--------------16:21-alternative---------------
#for part in msg.walk():
#    print part.get_content_type()
#    if part.get_content_maintype() == 'audio':
#        audio = part.get_payload(decode=1)
#        open('19.wav','wb').write(audio)
#----------------------------------------------

new = wave.open('19_1.wav', 'wb')
new.setparams(old.getparams())
for frame in range(old.getnframes()):
    new.writeframes(old.readframes(1)[::-1])
new.close()
[/code]

I have got mixed feelings about PythonChallenge. On one hand I got exposed to new stuff every level and learned a lot, on the other hand I am not really challenging myself, instead just googling and searching for answers. This doesn't help much regarding learning Python, and as the levels go up it takes more and more time to just figure out how the answers work. It's getting too much for me as a Python beginner. That being said, I decide to call a timeout, during which I will focus more on systematically learning Python. However, I will be back. ]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>126</wp:post_id>
  <wp:post_date>2013-07-10 16:40:30</wp:post_date>
  <wp:post_date_gmt>2013-07-10 20:40:30</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>level-19-please</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="post_tag" nicename="attention-later"><![CDATA[attention later]]></category>
  <category domain="post_tag" nicename="base64"><![CDATA[base64]]></category>
  <category domain="post_tag" nicename="decode"><![CDATA[decode]]></category>
  <category domain="post_tag" nicename="email"><![CDATA[email]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="category" nicename="python-challenge"><![CDATA[Python Challenge]]></category>
  <category domain="post_tag" nicename="re"><![CDATA[re]]></category>
  <category domain="post_tag" nicename="stringio"><![CDATA[StringIO]]></category>
  <category domain="post_tag" nicename="urllib"><![CDATA[urllib]]></category>
  <category domain="post_tag" nicename="wave"><![CDATA[wave]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Algo week 2: Quick Sort</title>
  <link>http://teacode.wordpress.com/2013/07/12/quick-sort/</link>
  <pubDate>Fri, 12 Jul 2013 21:01:45 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=133</guid>
  <description/>
  <content:encoded><![CDATA[This week's Algorithms course focused on Quicksort, which is a very clever and neat sorting algorithm. The core idea of Quicksort is really simple, find a pivot, put smaller elements on its left and bigger ones on its right, recursively do this with the left and right halves then it's done. The only thing that could be tricky is how to place the left and right. Tim Roughgardon did an excellent job explaining 'partition'. It starts by taking one element of a $latex n$ element list as 'pivot', then compares the rest elements with the pivot and does some swaps, after which all the smaller elements are on the left of the pivot and those equal and bigger ones on the right. This procedure only involves $latex n-1$ comparisons. Complexity analysis shows the average running time of Quicksort is $latex nlogn$, given the pivot is chosen randomly. Besides partition, Quicksort is so intuitive and clear that it can be easily implement in Python.<!--more-->

[code language="python"]
def quick_sort(array):
    &quot;&quot;&quot;
    Returns a sorted 'array' by quick sort algorithm via list comprehension,
    here 'array' is actually a list.
    &quot;&quot;&quot;

    if len(array) &lt;= 1:
        return array
    else:
        pivot = array[0]
        left = quick_sort([x for x in array[1:] if x &lt; pivot])
        right = quick_sort([x for x in array[1:] if x &gt;= pivot])
        return left + [pivot] + right
[/code]

The code above clearly omits partition, which results in $latex 2(n-1)$ comparisons. One would expect it will be less efficient compared to codes that partition, but it turns out opposite. What makes the code above more efficient without partition is the fact that Python's list comprehension is so well optimized(by C loop) that it takes way less time than general for loops.

Below is Quicksort with partition:
[code language="python"]

def element_swap(array, index1, index2):
    '''Swap the two elements with index1 and index2 in an array.'''

    array[index1], array[index2] = array[index2], array[index1]


def partition_head(array, head, tail):
    &quot;&quot;&quot;
    Partations an 'array' with its first element as 'pivot'.
    Returns the final index of the pivot.

    head: the index where partition starts.

    tail: the index where patition ends.

    pointer: initially points to the element immediately after head, increases
    by one after every swap during comparison, always points to the element
    that starts the right half, if no element on right half emerged yet, points
    to the last of the left half. Eventually points to the final index of pivot
    + 1.

    During comparison, swap only happens when element is smaller than pivot,
    swap like array[0], array[0] == array[0], array[0] is allowable. The final
    swap is bwteen pivot and the last element of left half.
    &quot;&quot;&quot;

    pivot = array[head]
    pointer = head + 1
    for index in range(head+1, tail):
        if array[index] &lt; pivot:
            element_swap(array, pointer, index)
            pointer += 1
    element_swap(array, pointer - 1, head)
    return pointer - 1


def quick_sort(array, head, tail):
    if tail - head &lt;= 1:
        return
    else:
        pivot = partition_head(array, head, tail)
        quick_sort(array, head, pivot)
        quick_sort(array, pivot+1, tail)
[/code]]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>133</wp:post_id>
  <wp:post_date>2013-07-12 17:01:45</wp:post_date>
  <wp:post_date_gmt>2013-07-12 21:01:45</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>quick-sort</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="partition"><![CDATA[partition]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="post_tag" nicename="quicksort"><![CDATA[quicksort]]></category>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Algo week 3: Karger min cut problem</title>
  <link>http://teacode.wordpress.com/2013/07/19/karger-min-cut-problem/</link>
  <pubDate>Fri, 19 Jul 2013 22:19:39 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=139</guid>
  <description/>
  <content:encoded><![CDATA[It is week three for the Algorithms course, and the main topic is the Karger minimum cut problem for an undirected graph. The Karger algo itself is clean and neat, however it can also be cumbersome to implement for whoever lacking good understanding of data structures. I spent some pre-work to figure out what would be the best choice to represent the graph, or adjacency list. My gut feeling is dictionary would work but not beautifully. I decide to construct a class to implement the graph for two reasons: make things neat and practice with class. I try to follow PEP8 and code with less comments in a sense that the style should make the codes easily readable. <!--more-->

The running time for code blow with just one iteration of <code>cut</code> is about 0.04 secs, which is pretty slow considering that $Latex n^{2}ln(n)$ iterations are needed to achieve $Latex 1/n$ error probability. Altough it actually runs fairly less number of trials to get a correct answer, I still think there is a lot to improve. And something worth pointing out is that <code>deepcopy</code> is a must before performing any cut in order to have the same fresh graph every time. For the class object I have here <code>deepcopy</code> takes tenth of the running time.

[code language="python"]
import random
import math
import copy
import time


class Adjacency(object):
    &quot;&quot;&quot;Describes the adjacency relationship among the nodes in a graph.

    node: a list of one vertex, or contracted vertices.

    edge: a list of vertices that 'node' is adjacent to.
    &quot;&quot;&quot;

    def __init__(self, node, edge):
        self.node = node
        self.edge = edge

    def contract(self, other):
        self.node += other.node
        self.edge = [i for i in self.edge + other.edge
                     if i not in self.node]

    def __repr__(self):
        return 'Adjacency(node = %r, edge = %r)' % (self.node, self.edge)


def cut(graph):
    &quot;&quot;&quot;Returns two contracted Adjacency where graph is cut.

    graph: a list of Adjacency objects.
    &quot;&quot;&quot;

    if len(graph) == 2:
        return graph
    else:
        rand_pick = random.choice(graph)
        merge_node = random.choice(rand_pick.edge)
        merge_pick = [i for i in graph if merge_node in i.node]
        rand_pick.contract(merge_pick[0])
        graph.remove(merge_pick[0])
        return cut(graph)


def min_cut(graph):
    &quot;&quot;&quot;Returns the graph cut where minimum crossing edges cut&quot;&quot;&quot;

    #with trail number n*n*ln(n), failure chance is 1/n
    trial_nu = int(math.pow(len(graph), 1) * math.log(len(graph)))
    min_cross = float('inf')
    for i in range(trial_nu):
        #!!!must call cut on a DEEP COPY of the graph!!!
        trial = cut(copy.deepcopy(graph))
        cut_cross = len(trial[0].edge)
        if cut_cross &lt; min_cross:
            min_cross = cut_cross
            out = trial
    return out, min_cross


def main():
    file_in = open('kargerMinCut.txt')
    data = [[[int(line.split()[0])], [int(i) for i in line.split()[1:]]]
            for line in file_in]
    graph = [Adjacency(i[0], i[1]) for i in data]
    return min_cut(graph)


if __name__ == '__main__':
    start = time.time()
    print main()
    print time.time() - start
[/code]

Note that the code above doesn't truly randomly select an <em>edge</em>, instead it first randomly select a <em>node</em> then randomly select one of its edges. Though it works, the right way to uniformly randomly select an edge is to choose one from all the edges.]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>139</wp:post_id>
  <wp:post_date>2013-07-19 18:19:39</wp:post_date>
  <wp:post_date_gmt>2013-07-19 22:19:39</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>karger-min-cut-problem</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="attention-later"><![CDATA[attention later]]></category>
  <category domain="post_tag" nicename="class"><![CDATA[class]]></category>
  <category domain="post_tag" nicename="cut"><![CDATA[cut]]></category>
  <category domain="post_tag" nicename="deepcopy"><![CDATA[deepcopy]]></category>
  <category domain="post_tag" nicename="graph"><![CDATA[graph]]></category>
  <category domain="post_tag" nicename="karger"><![CDATA[Karger]]></category>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:comment>
    <wp:comment_id>16</wp:comment_id>
    <wp:comment_author><![CDATA[Random Graphs Week &#8211; Monday | Eventually Almost Everywhere]]></wp:comment_author>
    <wp:comment_author_email/>
    <wp:comment_author_url>http://eventuallyalmosteverywhere.wordpress.com/2013/08/19/random-graphs-week-monday/</wp:comment_author_url>
    <wp:comment_author_IP>66.155.38.62</wp:comment_author_IP>
    <wp:comment_date>2013-08-19 17:51:17</wp:comment_date>
    <wp:comment_date_gmt>2013-08-19 21:51:17</wp:comment_date_gmt>
    <wp:comment_content><![CDATA[[&#8230;] Karger min cut problem (teacode.wordpress.com) [&#8230;]]]></wp:comment_content>
    <wp:comment_approved>1</wp:comment_approved>
    <wp:comment_type>pingback</wp:comment_type>
    <wp:comment_parent>0</wp:comment_parent>
    <wp:comment_user_id>0</wp:comment_user_id>
    <wp:commentmeta>
      <wp:meta_key>akismet_result</wp:meta_key>
      <wp:meta_value>false</wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value>a:4:{s:4:"time";d:1376949077.8313701152801513671875;s:7:"message";s:28:"Akismet cleared this comment";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}</wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>jabber_published</wp:meta_key>
      <wp:meta_value>1377915173</wp:meta_value>
    </wp:commentmeta>
    <wp:commentmeta>
      <wp:meta_key>akismet_history</wp:meta_key>
      <wp:meta_value>a:4:{s:4:"time";d:1377915174.38131999969482421875;s:7:"message";s:46:"teacode changed the comment status to approved";s:5:"event";s:15:"status-approved";s:4:"user";s:7:"teacode";}</wp:meta_value>
    </wp:commentmeta>
  </wp:comment>
</item>
<item>
  <title>Algo week 4: Graph search and Kosaraju SSC finder</title>
  <link>http://teacode.wordpress.com/2013/07/27/algo-week-4-graph-search-and-kosaraju-ssc-finder/</link>
  <pubDate>Sat, 27 Jul 2013 16:05:12 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=143</guid>
  <description/>
  <content:encoded><![CDATA[Breath First Search(BFS) and Depth First Search(DFS) are the basics of graph search, which I actually learned about before from edx's popular AI course. That's when I started to check out what computer science could be. I was taking another popular edx course(MIT's intro to CS) at the same time, which was good because the course level matched my weak background. But the AI course was just beyond my scope, with no surprise I struggled a lot and I still remember hours and hours me staring at the code and googling around trying to make sense everything. What I am proud of is at the end I managed to finish the course with a final grade of 94%. I should probably had taken that course some time later and I could be more efficient. But that achievement was huge for me at that time and it was definitely one of the indispensables that drive me go deeper into CS.<!--more-->

Well, it's a little off the topic, let's get back to graph search. BFS explores the nodes in layers, so it is capable of finding the shortest path from the source node to a certain node. And for undirected graph, it can also compute all connected components. DFS aggressively goes deep into a branch until it reaches an end then backtracks to shallow nodes. It is good at finding topological ordering of a directed acyclic graph and connected components in directed graphs. Despite of the different search behaviors, BFS and DFS are almost the same code wise, the only difference is BFS stores nodes in a queue(FILO) while DFS uses a stack(FIFO). Both algorithms have a linear running time of $Latex O(m+n)$, where $Latex m$ is the number of edges and $Latex n$ is number of nodes. While BFS and DFS can be implemented iteratively, DFS could also be done in a slicker recursive way. That being said, the star of this weak is Kosaraju's two pass algorithm for computing strongly connected components(SCC). I didn't grasp the idea of the algo when I watched the video, and to be honest even after I successfully implemented the algo I still wonder why it works. The algo itself is not too hard:
<ol>
	<li>Create a reversed graph with all arches reversed.</li>
        <li>Run DFS loop on the reversed graph to compute the finishing time of each node.</li>
        <li>Run DFS loop on the original loop processing the nodes in decreasing order of finishing times.</li>
</ol>
The SSCs are the nodes with the same leaders(the biggest node number in the group). The DFS loop is very neat, what might be confusing is to track all the stuff: current time, current source node, leader, finishing time and the explored nodes. These variables need to be global in the sense of tracking, however the rule of thumb for Python is to stay away from globals. So I put everything into a <code>Track</code> class, being instance attributes they are safe and easy to handle. Recursion tracks the finishing time of each node beautifully and painlessly. I tried the iterative approach and my way of time tracking was just ugly. There must be a better way handling time tracking iteratively, but who doesn't like recursion anyway?  However, because of the huge size of graph, and Python's default recursion limit setting, you will probably certainly encounter the "maximum recursion depth reached" error. Fear not, just push the recursion limit and also increasing the stack size. Taking advantage of the hardware is by no means cheating, at least not for me:). That's a fun week for Algo!

[code language="python"]
import sys
import time
import resource
from itertools import groupby
from collections import defaultdict


#set rescursion limit and stack size limit
sys.setrecursionlimit(10 ** 6)
resource.setrlimit(resource.RLIMIT_STACK, (2 ** 29, 2 ** 30))


class Track(object):
    &quot;&quot;&quot;Keeps track of the current time, current source, component leader,
    finish time of each node and the explored nodes.&quot;&quot;&quot;

    def __init__(self):
        self.current_time = 0
        self.current_source = None
        self.leader = {}
        self.finish_time = {}
        self.explored = set()


def dfs(graph_dict, node, track):
    &quot;&quot;&quot;Inner loop explores all nodes in a SCC. Graph represented as a dict,
    {tail node: [head nodes]}. Depth first search runs recrusively and keeps
    track of the parameters&quot;&quot;&quot;

    track.explored.add(node)
    track.leader[node] = track.current_source
    for head in graph_dict[node]:
        if head not in track.explored:
            dfs(graph_dict, head, track)
    track.current_time += 1
    track.finish_time[node] = track.current_time


def dfs_loop(graph_dict, nodes, track):
    &quot;&quot;&quot;Outter loop checks out all SCCs. Current source node changes when one
    SCC inner loop finishes.&quot;&quot;&quot;

    for node in nodes:
        if node not in track.explored:
            track.current_source = node
            dfs(graph_dict, node, track)


def scc(graph, reverse_graph, nodes):
    &quot;&quot;&quot;First runs dfs_loop on reversed graph with nodes in decreasing order,
    then runs dfs_loop on orignial graph with nodes in decreasing finish
    time order(obatined from firt run). Return a dict of {leader: SCC}.&quot;&quot;&quot;

    out = defaultdict(list)
    track = Track()
    dfs_loop(reverse_graph, nodes, track)
    sorted_nodes = sorted(track.finish_time,
                          key=track.finish_time.get, reverse=True)
    track.current_time = 0
    track.current_source = None
    track.explored = set()
    dfs_loop(graph, sorted_nodes, track)
    for lead, vertex in groupby(sorted(track.leader, key=track.leader.get),
                                key=track.leader.get):
        out[lead] = list(vertex)
    return out

[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>143</wp:post_id>
  <wp:post_date>2013-07-27 12:05:12</wp:post_date>
  <wp:post_date_gmt>2013-07-27 16:05:12</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>algo-week-4-graph-search-and-kosaraju-ssc-finder</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
  <category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
  <category domain="post_tag" nicename="graph-search"><![CDATA[graph search]]></category>
  <category domain="post_tag" nicename="kosaraju"><![CDATA[Kosaraju]]></category>
  <category domain="post_tag" nicename="recursion"><![CDATA[recursion]]></category>
  <category domain="post_tag" nicename="scc"><![CDATA[SCC]]></category>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Algo week 5: Heap and Dijkstra's shortest path</title>
  <link>http://teacode.wordpress.com/2013/08/02/algo-week-5-heap-and-dijkstras-shortest-path/</link>
  <pubDate>Sat, 03 Aug 2013 03:51:59 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=156</guid>
  <description/>
  <content:encoded><![CDATA[This week's content is rich, it covers Dijksrta's shortest path algorithm and several data structure, among which heap is emphasized.

Heap is a tree data structure whose parent-child order pattern is always the same, namely a parent node is always either bigger or smaller than its children, which leads to a max heap or a min heap. A binary heap has no more than two child nodes for each node. As a specific data structure, heap is also referred to priority queue, an abstract data structure. The typical operations of heap (without breaking the invariant) includes:<!--more-->
<ul>
        <li>Insert: add new object, running time $Latex O(logn)$</li>
	<li>Extract-Min: remove the top element, running time $Latex O(logn)$</li>
	<li>Heapify: batch insertion to build heap, running time $Latex O(n)$</li>
</ul>
While all this operations can be implemented using swaps, bubble ups and bubble downs, Python has a library <code>heapq</code> for heap, and above operations are easily fulfilled by <code>heappush()</code>, <code>heappop()</code> and <code>heapify()</code>. The most simple heap could be a heapified list containing integers. With the property of heap, heap sort kicks in naturally: heapify a given list and repeatly extract min. More efficient use of heap is priority queue which usually contains tuples in form of (priority, node). A priority queue should also be capable of following operations (without breaking invariant):
<ul>
	<li>Insert with priority: add new or update an existing object with desired priority</li>
	<li>Delete: remove any arbitrary object from the queue</li>
</ul>
Although Python's <code>heapq</code> library does not support such operations, it gives a neat <a href="http://docs.python.org/2/library/heapq.html#priority-queue-implementation-notes" target="_blank">demonstration</a> on how to implement them, which is a slick trick and works like a charm.

Dijkstra's shortest path algorithm is very fairly intuitive:
<ol>
	<li>Initialize the passed nodes with the source and current shortest path with zero.</li>

	<li>Include the node that minimize the current shortest path plus the edge distance among all edges whose tail are in the passed nodes and head in uncharted nodes.</li>

	<li>Update the current shortest path and repeat step 2 until all nodes are passed.</li>
</ol>
Basically, the whole algorithm is just one loop, it can be implemented naively with running time $Latex O(mn)$, where $Latex m$ and $Latex n$ are number of edges and nodes. It's quadratic and picking the right node could be very clumsy. However, with the right data structure, a priority queue, picking the right node is just as simple as extracting the minimum (the hard part is to update priorities while maintaining invariant, but it's already demoed!), and BOOM the running time reduces to $Latex O(mlog_{2}n)$. We gotta love trees, and heaps. :)

Below is the implementation of priority queue and Dijkstra' algorithm:
[code language="python"]
import heapq


class PriorityQueue(object):
    &quot;&quot;&quot;Priority queue based on heap, capable of inserting a new node with
    desired priority, updating the priority of an existing node and deleting
    an abitrary node while keeping invariant&quot;&quot;&quot;

    def __init__(self, heap=[]):
        &quot;&quot;&quot;if 'heap' is not empty, make sure it's heapified&quot;&quot;&quot;

        heapq.heapify(heap)
        self.heap = heap
        self.entry_finder = dict({i[-1]: i for i in heap})
        self.REMOVED = '&lt;remove_marker&gt;'

    def insert(self, node, priority=0):
        &quot;&quot;&quot;'entry_finder' bookkeeps all valid entries, which are bonded in
        'heap'. Changing an entry in either leads to changes in both.&quot;&quot;&quot;

        if node in self.entry_finder:
            self.delete(node)
        entry = [priority, node]
        self.entry_finder[node] = entry
        heapq.heappush(self.heap, entry)

    def delete(self, node):
        &quot;&quot;&quot;Instead of breaking invariant by direct removal of an entry, mark
        the entry as &quot;REMOVED&quot; in 'heap' and remove it from 'entry_finder'.
        Logic in 'pop()' properly takes care of the deleted nodes.&quot;&quot;&quot;

        entry = self.entry_finder.pop(node)
        entry[-1] = self.REMOVED
        return entry[0]

    def pop(self):
        &quot;&quot;&quot;Any popped node marked by &quot;REMOVED&quot; does not return, the deleted
        nodes might be popped or still in heap, either case is fine.&quot;&quot;&quot;

        while self.heap:
            priority, node = heapq.heappop(self.heap)
            if node is not self.REMOVED:
                del self.entry_finder[node]
                return priority, node
        raise KeyError('pop from an empty priority queue')


def dijkstra(source, pq, edges):
    &quot;&quot;&quot;Returns the shortest paths from the source to all other nodes.
    'edges' are in form of {head: [(tail, edge_dist), ...]}, contain all
    edges of the graph, both directions if undirected.&quot;&quot;&quot;

    size = len(pq.heap) + 1
    processed = [source]
    uncharted = set([i[1] for i in pq.heap])
    shortest_path = {}
    shortest_path[source] = 0
    while size &gt; len(processed):
        min_dist, new_node = pq.pop()
        processed.append(new_node)
        uncharted.remove(new_node)
        shortest_path[new_node] = min_dist
        for head, edge_dist in edges[new_node]:
            if head in uncharted:
                old_dist = pq.delete(head)
                new_dist = min(old_dist, min_dist + edge_dist)
                pq.insert(head, new_dist)
    return shortest_path
[/code]
]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>156</wp:post_id>
  <wp:post_date>2013-08-02 23:51:59</wp:post_date>
  <wp:post_date_gmt>2013-08-03 03:51:59</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>algo-week-5-heap-and-dijkstras-shortest-path</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="alogrithm"><![CDATA[alogrithm]]></category>
  <category domain="post_tag" nicename="dijkstra"><![CDATA[Dijkstra]]></category>
  <category domain="post_tag" nicename="heap"><![CDATA[heap]]></category>
  <category domain="post_tag" nicename="heapq"><![CDATA[heapq]]></category>
  <category domain="post_tag" nicename="priority-queue"><![CDATA[priority queue]]></category>
  <category domain="post_tag" nicename="python"><![CDATA[python]]></category>
  <category domain="post_tag" nicename="shortest-path"><![CDATA[shortest path]]></category>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
</item>
<item>
  <title>Algo week 6: Hash table and Bloom filter</title>
  <link>http://teacode.wordpress.com/2013/08/10/algo-week-6-hash-table-and-bloom-filter/</link>
  <pubDate>Sat, 10 Aug 2013 17:02:27 +0000</pubDate>
  <dc:creator>teacode</dc:creator>
  <guid isPermaLink="false">http://teacode.wordpress.com/?p=163</guid>
  <description/>
  <content:encoded><![CDATA[It's the end of the Algo part 1, and the topic is largely hash table, one of the most important data structures. Hash table is probably not something new if one has ever fiddled around any programming language. Because of the amazing lookup speed <code>O(1)</code>, almost every language has its own build-in hash table, such as <code>dict</code> for Python, <code>hash</code> for Ruby, etc. Essentially, hash tables are key-value pairs, while the concept may looks simple on the surface, it is actually pretty complicated under the hood. A good hash table implementation mainly depends on a good hash function which should be fast to evaluate and capable of spreading data out randomly and uniformly into 'buckets'. One necessary condition of a hash table is the load factor(number of objects over number of buckets) need to be <code>O(1)</code>.<!--more--> And some basic rules for choosing number of buckets:
<ol>
	<li>Choose n to be a prime</li>

	<li>Not close to a power of 2</li>

	<li>not close to a power of 10</li>

</ol>



An ideal hash function would avoid any possible collisions so that any distinct data would have distinct keys. However, such a hash function does not exist, because no matter what hash function you come up with there always exists a pathological data set. Typical solution to this problem is to design a family of hash functions, almost all of which spread out data pretty evenly, and then randomly choose hash functions from that family. By doing so, the collision potability is managed less than $Latex 1/n$, where $Latex n$ is number of buckets. And functions in that family are 'universal' hash functions.

A bloom filter utilizes universal hash functions to achieve fast insertions and lookups with high space efficiency and yet not a hash table in senses that it doesn't actually store any object, no deletions are supported, and furthermore there exists small false positive probability.  Bloom filter works as follows:
<ol>
	<li>Use a $Latex n$ bits array $Latex A$ to store existence status.</li>
	<li>Use $Latex k$ hash functions for object-existence pair mapping.</li>
	<li>Insertion: set $Latex A[h_{i}(x)] = 1$ for $Latex i = 1,2,...,k$ regardless previous bit value.</li>
	<li>Lookup: object exists if $Latex A[h_{i}(x)] = 1$ for all $Latex i = 1,2,...,k$.</li>
</ol>
Bloom filter has no false negatives: if an object is previously inserted, a lookup will always confirm its existence. However, since there are chances that bits for new insertion might have been set to 1 by previous insertions, false positives are possible. Luckily, because of the good choices of universal hash functions, the probability of false positives is less than $Latex 1-e^{\frac{-k}{b}}$, where <code>b</code> is number of bits per object. To illustrate, with <code>b=8, k=5</code>, the error probability is only about 2%.




There are two homework problems this week: one is (arguably) about hash table, and the other is about heap (from last week). I say the first problem is arguably about hash table because it can be solved more naturally without thinking about hashing. To be honest, I got stuck when I tried too hard focusing on a hash table approach without analyzing the problem. For a single 2sum problem, with each number in a number set(python's set is a hash table), looking up its corresponding part cost <code>O(1)</code> time, and linear time is required to traverse the set, which is not bad. Things become interesting when we have more than a single 2sum problem, say <code>10,000</code>. This means <code>10,000</code> lookups per number in the set, namely billions of lookups if the set has a size of million. The point is that lookup is still fast but we just got plain too many of them. The trick is to observe the features of the 2sum problem, in the homework 2sum is desired in a range of <code>[-10000, 10000]</code>, which is rather a small range compared to the randomly large numbers in the txt file. So instead of hashing, simply sort the numbers as a list, and for each number $Latex i$ decide a window <code>[-10000-i, 10000-i]</code>, then find the numbers in that window using the excellent <code>bisect</code> module. It's done in several seconds. One can also build customized has table with bucket size of the range width, and then do the same window trick to solve the problem quickly. However, it is not faster and actually a bit clumsy compared to bisect approach. Note that the window trick works simply because the 2sum range is small and numbers in the file are large and uniformly distributed, if the window size is close to the scale of numbers in the file then it would fail. I guess there might be better hash table approaches when window blows, but I doubt it can be easily grasped. Below are codes with bisect approach:
[code language="python"]
import bisect


def two_sum(array):
    &quot;&quot;&quot;Returns the numbers from [-WIDTH, WIDTH] that can be obtained by
    summing up any two elements in 'array'.&quot;&quot;&quot;

    WIDTH = 10000
    out = set()
    for i in array:
        lower = bisect.bisect_left(array, -WIDTH - i)
        upper = bisect.bisect_right(array, WIDTH - i)
        out |= set([i + j for j in array[lower:upper]])
    return out
[/code]




The second problem is to main medians for a streamed number list. The idea for this problem is to have two heaps: a <code>heap_lo</code> as a max_heap to store the smaller half of received numbers with its maximum as top node, a <code>heap_hi</code> as a min_heap to store the bigger half with its minimum as top node. With this setup, when a new number is received one just check against the top nodes of <code>heap_lo</code> and <code>heap_hi</code>, and insert in the proper heap. To keep the two heaps balanced, pop the top node from the longer heap and insert it into the shorter heap. The median is always one of the top nodes from <code>heap_lo</code> and <code>heap_hi</code>. So the key is to have two types of heaps, unfortunately python's <code>heapq</code> module only supports min_heap. Fear not, heap is actually not hard to implement, <a href="https://github.com/ChuntaoLu/Algorithms/blob/master/week6%20Hash%20table/heap.py">here</a> is my implementation of heap which support both max_heap and min_heap. Once you have the right heaps, maintaining medians is as simple as below:
[code language="python"]
import heap


def maintain_median(stream):
    &quot;&quot;&quot;Returns the medians for the sequence of already popped elements every
    time when stream pops.&quot;&quot;&quot;

    out = [stream.pop(0)]
    heap_lo, heap_hi = [out[0]], []
    while stream:
        num = stream.pop(0)
        if num &gt;= heap_lo[0]:
            heap.heap_insert(heap_hi, num, 'min')
        else:
            heap.heap_insert(heap_lo, num, 'max')
        if len(heap_lo) &gt; len(heap_hi) + 1:
            heap.heap_insert(heap_hi, heap.heap_extract(heap_lo, 'max'), 'min')
        if len(heap_hi) &gt; len(heap_lo) + 1:
            heap.heap_insert(heap_lo, heap.heap_extract(heap_hi, 'min'), 'max')
        if len(heap_lo) &gt;= len(heap_hi):
            out.append(heap_lo[0])
        else:
            out.append(heap_hi[0])
    return out
[/code]  ]]></content:encoded>
  <excerpt:encoded><![CDATA[]]></excerpt:encoded>
  <wp:post_id>163</wp:post_id>
  <wp:post_date>2013-08-10 13:02:27</wp:post_date>
  <wp:post_date_gmt>2013-08-10 17:02:27</wp:post_date_gmt>
  <wp:comment_status>open</wp:comment_status>
  <wp:ping_status>open</wp:ping_status>
  <wp:post_name>algo-week-6-hash-table-and-bloom-filter</wp:post_name>
  <wp:status>publish</wp:status>
  <wp:post_parent>0</wp:post_parent>
  <wp:menu_order>0</wp:menu_order>
  <wp:post_type>post</wp:post_type>
  <wp:post_password/>
  <wp:is_sticky>0</wp:is_sticky>
  <category domain="category" nicename="algorithm"><![CDATA[algorithm]]></category>
  <category domain="post_tag" nicename="bisect"><![CDATA[bisect]]></category>
  <category domain="post_tag" nicename="bloom-filter"><![CDATA[Bloom filter]]></category>
  <category domain="post_tag" nicename="dict"><![CDATA[dict]]></category>
  <category domain="post_tag" nicename="hash"><![CDATA[hash]]></category>
  <category domain="post_tag" nicename="hash-table"><![CDATA[hash table]]></category>
  <category domain="post_tag" nicename="heap"><![CDATA[heap]]></category>
  <category domain="post_tag" nicename="lookup"><![CDATA[lookup]]></category>
  <wp:postmeta>
    <wp:meta_key>geo_public</wp:meta_key>
    <wp:meta_value><![CDATA[0]]></wp:meta_value>
  </wp:postmeta>
  <wp:postmeta>
    <wp:meta_key>_publicize_pending</wp:meta_key>
    <wp:meta_value><![CDATA[1]]></wp:meta_value>
  </wp:postmeta>
</item>
  </channel>
</rss>
